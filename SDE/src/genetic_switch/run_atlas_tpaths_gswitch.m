function run_atlas_tpaths_gswitch()
%TODO: comments

close all;

data = load('gswitch_atlas.mat');
new_S = data.new_S;
L = data.L;

data = load('gswitch_driver.mat');
params = data.params;

net_info = params.net_info;
net = net_info.net;
neighbors = net_info.neighbors;
edges = net_info.edges;
deg = net_info.deg;
max_deg = net_info.max_deg;

delta = params.delta;
d = params.d;
dt = params.dt;
rho = params.rho;
m = params.m;
f = params.f;
dt_sim = params.dt_sim;
S = params.S;

% fprintf("TESTING: setting dt to a smaller value \n");
dt = 0.01;

%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%NOTE: this is the main test file for comparing simulators
%Data generated by this file should be used by a number of other test files,
%one for transition paths, one for histograms...etc

%T = 10^7; %length of time interval for simulation
%T = 10^5;

dist = 200; %radius of the basin of a equilibrium point
dist_sq = dist.^2;

max_switches = 100; %set max number of transitions to track

%%%Define equilibria points and regions of interest for path tracking
%xi - asympt. stable equilibria representing inactive switch
%xa - asympt. stable equilibria representing active switch
xi = [0.0402067142317042; 1.60826856926817; 0.000258652779089588];
xa = [29.3768600805981; 1175.07440322392; 138.079985311206];

global p1
global p2
p1 = xi;
p2 = xa;

regions = [p1,p2];

%%%Assign net points to closest region, if within presciribed distance
region_net = zeros(size(net,2),1);
for n = 1 : size(net,2)
    [dmin,imin] = min(sum((net(:,n) - regions).^2,1));
    if dmin < dist_sq
        region_net(n) = imin;
    end
end

%%%TODO: fix this block of lines
%%%Assign nitial simulation point
%assign a point in region 1
assigned = false;
n = 1;
while ~assigned
    if region_net(n) ==1
        Xzero = net(:,n)
        n
        assigned = true;
    else
        n = n + 1;
    end
end
%Xzero = net(:,1);

%Plot Delta Net
figure;hold on;grid;view(3);
xlabel('x','Fontsize',20);
ylabel('y','Fontsize',20);
set(gca,'Fontsize',20);
for i = 1 : length(edges)
    xedge = [net(1,edges(i,1)),net(1,edges(i,2))];
    yedge = [net(2,edges(i,1)),net(2,edges(i,2))];
    zedge = [net(3,edges(i,1)),net(3,edges(i,2))];
    plot3(xedge,yedge,zedge,'color','k','LineWidth',0.25);
end
drawnow;

%%
%%%%%Calculate transition paths over several different noises of system
%noises = [100,75,60,50];
noises = params.noise;
for k = 1:length(noises)
    noise = noises(k);
    sq_noise = sqrt(noise);
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %Original Simulator
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %Compute SDE until time dt*N
    %initialize region list, transition tracking
    [dmin,imin] = min(sum((Xzero - regions).^2,1));
    if dmin < dist_sq
        init_region = imin;
    else
        init_region = 0;
    end
    
    original_switches = []; %list of all switches between regions and corresponding times
    switch_count = 0; %tracks number of transitions
    
    tic;
    
    %simulate until certain number of transitions are observed
    while switch_count < max_switches
        t = 0;
        flag = sign(init_region);
        step = 0; %number of steps iterated
        region = init_region;
        
        
        x = Xzero;
     
        %restart simulation once p2 is reached
        while region~=2
            step = step + 1; %number of simulation steps before restart
            
            %Take Euler-Maruyama step
            dW = sqrt(dt_sim)*randn(3,1); %Brownian random increment in R^D
            x = x + switch_drift(x)*dt_sim + sq_noise*dW;
            
            %For now: not tracking charts, just tracking regions
            [~,region_check] = min(sum((x - regions).^2,1));
            
            %only assign a region value if the point is close enough
            if region_check < dist_sq
                new_region = region_check;
            else
                new_region = 0;
            end
            
            if new_region > 0
                if flag == 0
                    region = new_region;
                    t = 0;
                    flag = 1;
                else
                    if region ~= new_region
                        
                        %we've observed a transition!
                        switch_count = switch_count + 1;
                        original_switches = [original_switches;region,new_region,t];
                        t = 0;
                        region = new_region;
                        save('original_tswitch.mat','original_switches','noise');
                        fprintf("transition %d \n",switch_count);
                    end
                end
            end
            t = t+dt_sim;
            
            if mod(step,100000000) == 0
                fprintf("step %d \n",step);
                % 		fprintf("step %d of %f \n",step,N);
                toc;
            end
            
            %increment time-counting step
            
            
        end
        toc;
    end
    original_time = toc;
    %Save info relevant for plotting mean switching times,
    %and save rest of information for archival purposes
    
    %one copy for reading outputs in 'makestats' file, another for finding data
    %by noise values
    save('original_tswitch.mat','original_switches','noise','original_time');
    filename = ['original_tswitch','_','noise',num2str(noise),'.mat'];
    copyfile('original_tswitch.mat',filename);
    
    %save entire workspace
    filename = [datestr(now, 'dd_mmm_yyyy_HH_MM'),'_','run_atlas_tpaths_gswitch.mat'];
    save(filename);
    fprintf("original sim paths are simulated! \n");
    
    %%
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %Reduced(ATLAS) Simulator
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%%TESTING: getting running averages of norms of simulations at different
    %%%charts
    N = size(net,2);
    
    fprintf("simulating atlas paths\n");
    
    %%%Find the initial chart to start reduced simulator
    [~,init_chart] = min(sum((Xzero - net).^2,1));
    num_nbr = deg(init_chart);
    init_L = L(:,1:(m+1)*(num_nbr + 1),init_chart);
    
    %%%Embed initial condition for original simulator,center,then run atlas simulator
    [local_L,Yzero] = LMDS(init_L,Xzero,rho,d);
    Yzero = Yzero - local_L(:,1);
    
    %%%Compute SDE
    %initialize region list, transition tracking
    init_region = region_net(init_chart);
    learned_switches = []; %list of all switches between regions and corresponding times
    charts = []; %list of all charts visited, for plotting
    switch_count = 0; %tracks number of transitions
    tic;
    
    %read in Struct new_S
    c = new_S.c;
    b = new_S.b;
    sigma = new_S.sigma;
    T = new_S.T;
    mu = new_S.mu;
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %TESTING: bad steps
    %if euler step goes too far ('bad'), collect point and add
    %to time spent in 'bad' steps
    %bad_points array: badpoint(:,:,n) is array of bad points from chart n,
    %                  each column is a differnt data point in R^d
    
    %bad_points =  struct("; %initialize set of bad steps
    bad_time = 0;
    total_time = 0;
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    %simulate until 'switch_count' number of transitions are observed
    while switch_count < max_switches
        t = 0;
        step = 0; %number of steps iterated
        flag = sign(init_region);
        region = init_region;
        chart = init_chart; %initial chart
        y = Yzero; %initial simulator value in reduced space
        
        while region ~= 2
            step = step + 1;
            
            
            %%%%Code from 'noisy_learned_simulator_step%%%%%%%%%%%%%%%%%%%%%%%%
            %TESTING: explicitly writing out the simulator step, the funciton
            %uses a lot of memory by reloading data structures every step
            %[y,new_chart] = noisy_learned_simulator_step(y,chart,new_S,neighbors,deg,d,dt,delta,noise);
            %[y,new_chart] = learned_simulator_step(y,chart,new_S,neighbors,deg,d,dt,delta);
            
            i = chart;
            
            num_nbr = deg(i);
            net_nbr = [i neighbors(i,1:num_nbr)];
            
            
            %%%Find closest chart to y in chart i coords
            C = squeeze(c(:,i,net_nbr)); %collect centers for chart i
            [~,imin] = min(sum((y - C).^2,1));
            j = net_nbr(imins);
            
            if j ~= i
                %TODO: remove squeezes, not necessary for this step
                %%%Set new chart to j
                mu_ij = squeeze(mu(:,i,j));
                mu_ji = squeeze(mu(:,j,i));
                T_ij = squeeze(T(:,:,i,j));
                
                y = T_ij*(y - mu_ij) + mu_ji;
            end
            
            %%%Forward Euler step
            eta = sqrt(dt)*randn(d,1);
            
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            %TESTING: no added noise in learned simulator, it's on a
            %different scale than the original simulator
            %y = y + b(:,j)*dt + sigma(:,:,j)*sqrt(noise)*eta;
            y = y + b(:,j)*dt + sigma(:,:,j)*eta;
            
            
            %%%prevent escape from local chart by applying wall function
            if norm(y) > (3/2)*delta
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                %%%%TESTING: bad steps
                %if euler step goes too far ('bad'), collect point and add
                %to time spent in 'bad' steps
                bad_time = bad_time + dt;
                %bad_points(:,:,j) = [bad points y];
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                
                y = (1/norm(y))*y*(2*delta - (1/2)*delta*exp(3 - (2/delta)*norm(y)));
                
            end
            new_chart = j;
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            
            chart = new_chart;
            
            %calculate transition path
            new_region = region_net(chart);
            if new_region > 0
                if flag == 0
                    region = new_region;
                    t = 0;
                    flag = 1;
                else
                    if region ~= new_region
                        
                        %we've observed a transition!
                        switch_count = switch_count + 1;
                        learned_switches = [learned_switches;region,new_region,t];
                        t = 0;
                        region = new_region;
                        save('learned_tswitch.mat','learned_switches','noise');
                        
                        fprintf("transition %d \n",switch_count);
                        toc;
                    end
                end
            end
            t = t+dt;
            total_time = total_time + dt;
            
            %NOTE: commented out currently to save on run-time
            %update charts visted list
%             charts = unique([charts;chart]);
            
            if mod(step,1000000) == 0
                fprintf("step %d \n",step);
                bad_time_ratio = bad_time/total_time;
                fprintf("bad_time_ratio = %f \n",bad_time_ratio);
                toc;
            end
        end
    end
    atlas_time = toc;
    
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %TESTING: bad point
    bad_time_ratio = bad_time/total_time;
    fprintf("(bad) time spent stepping to wall: %f \n",bad_time);
    fprintf("time spent: %f \n",total_time);
    fprintf("ratio of bad_time/atlas_time = %f \n",bad_time_ratio);
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    %%%%NOTE: commenting out to save running time
    %%%Plots all visited charts by atlas
%      hold on;
%      for k = 1:length(charts)
%          plot3(net(1,charts(k)),net(2,charts(k)),net(3,charts(k)),'.','color','y','Markersize',20);
%      end
%      view(3);
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    fprintf("atlas paths are simulated! \n");
    
    %Save info relevant for plotting mean switching times,
    %and save rest of information for archival purposes
    save('learned_tswitch.mat','learned_switches','charts','noise','atlas_time');
    filename = ['learned_tswitch','_','noise',num2str(noise),'.mat'];
    copyfile('learned_tswitch.mat',filename);
    
end

filename = [datestr(now, 'dd_mmm_yyyy_HH_MM'),'_','run_atlas_tpaths_gswitch.mat'];
save(filename);

end

function dX = switch_drift(x)
%%%Parameters
k0 = 1; %DNA activation
k1 = 0.0002; %rate of dimerization
gamma_1 = 2;  %rate of de-dimizeration
gamma_0 = 50; %DNA inactivation
gamma_m = 10; %mRNA decay
gamma_n = 1; %protein decay
a = 400;	%transcription
a0 = 0.4;
b = 40;		%translation


%x is a vector in R^3
m = x(1);
n = x(2);
d = x(3);

%
dm = (a0*gamma_0 + a*k0*d)/(gamma_0 + k0*d) - gamma_m*m;
dn = b*m - gamma_n*n - 2*k1*n^2 + 2*gamma_1*d;
dd = k1*n^2 - gamma_1*d;

dX = [dm;dn;dd];

end
